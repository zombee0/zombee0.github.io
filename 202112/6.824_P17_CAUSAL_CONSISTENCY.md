# 6.824_P17_CAUSAL_CONSISTENCY

前12节课的视频，建议参考翻译https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/

这篇文章只是记录一些要点和自己的思考，有助于理解第17节课，但和之前的翻译相比，区别较大

因果一致性

在引出因果一致性之前，先讲了两个更弱的一致性

## 最终一致性

假设有多个数据中心，数据读写操作直接在本地进行，然后写操作复制到其他数据中心。为了能够达到最终一致，采用数据版本的方式，考虑到在多个数据中心的并发操作，使用时间戳作为数据版本，并以数据中心的id作为辅助判断，当数据发生冲突时，时间戳新的保留，旧的被覆盖，如果时间戳一致性，使用id辅助判决。

使用时间戳作为版本的一个问题是，各个数据中心之间的时间是有偏差的，可以采用Lamport时钟来处理。

## Lamport Clock

数据中心会记录已知的最大时间戳T_MAX，当该数据中心需要分配时间戳时，取MAX(T_MAX+1, system.time)

## 问题

 最终一致性是一种比较弱的一致性，比如存在一下问题，用户A先上传了一张照片，然后更新了自己的照片列表。数据在传输到另一个数据中心时，照片列表先于照片到达，此时用户B查询获取了新列表，但是访问列表中的新照片发现没有。

## 加BARRIERS

解决问题的办法是在两个操作之间加一个sync操作，sync(k, #v)只有在所有的服务器都看到了数据k的#v以上版本时才执行后续操作。因此上面的示例中用户A先上传照片，然后sync，然后更新List。

等待所有服务器响应可能会由于某一台服务器宕机或者很慢而拖累整个操作，那么可以采用Quorum的方式，R+W > N。

## 扩展性问题

上面介绍的系统存在扩展性问题，客户端在本地数据中心完成操作后，要将所有的写操作放入日志服务器，并由日志服务器按照顺序发送给其他的数据中心，这就使得日志服务器成为系统扩展的瓶颈。

## COPS

Clusters of Order-Preserving Servers

客户端一系列操作如：Get(X) —> Xv2, Get(Y) —> Yv4, Put(Z,K) —> Zv4，那么当服务器向其他数据中心发送Put时会携带已知的上下文，Put(Zv3, K, Xv2, Yv4)，这实际上是一种依赖关系，意味着Xv2早于Zv3，Yv4早于Zv3。收到数据副本的其他数据中心的服务器，会检查当前的X、Y版本，在版本尚未到达依赖版本之前，Zv3不会生效。

跟前面相比，COPS不需要特定的服务器了，因为依赖关系已经在信息中了。

## Causal Consistency

 因果一致性的好处是对于没有依赖关系的操作，可以不用保证顺序，从而提高性能。

但是Causal Consistency对于有些情况是无法保证的，比如客户端C1更新了数据K，客户端C2读取时并不能保证读取到的数据是最新的。