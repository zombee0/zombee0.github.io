## 6.824_P12_DistributedTransaction

前12节课的视频，建议参考翻译https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/

第12节课讨论的内容是分布式事务。

分布式事务主要有两大主题：并发控制和原子提交

对于分布式事务数据分布在多台服务器上，执行过程中仍然要满足ACID，同时有多个并发行为的情况下，I(隔离性)意味着并发控制，可序列化，通过并发控制将使用同样数据的事务进行隔离和序列化。原子提交意味着同一事务多台服务器的数据操作要么同时提交，要么同时取消，如果一部分已经提交，那么剩余部分即便是故障之后也要恢复提交。

## 并发控制

并发控制策略主要有两种，悲观并发控制和乐观并发控制。两种策略应用取决于负载中的冲突是否频繁。

这节课主要讨论悲观并发控制，第14节课讨论乐观并发控制。

可以使用两阶段锁来实现悲观并发控制，两阶段锁在事务使用数据之前获取锁，并一直持有知道事务结束释放锁。不能尽早释放锁的原因之一是可能出现读未提交，事务1修改了数据X，并释放了锁，但此时事务尚未结束，事务2读取了修改后的X值，之后事务1进行了回滚，数据X回到原值，事务2读取到了一个并未提交的数据。

两阶段锁很容易产生死锁，比如事务1需要X和Y的锁，并且获取了X锁等待Y锁，事务2也需要X和Y锁，但是获取了Y锁等待X锁，如果不加任何处理，则此处产生了死锁。

通常死锁可以通过超时判断来使其中一个先放弃锁。

## 两阶段提交

对于一个分布式事务来说，可能涉及多台服务器，他们要么全部提交，要么全部取消。并且需要保证在机器故障、消息丢失等情况下仍然满足原子提交。两阶段提交是方案之一。

一个事务会有一个事务协调者，多个事务参与者。在事务提交之前，协调者会向每个参与者发送Prepare请求，参与者检查自身状态是否可以提交。事务参与者本身会有一个数据表单，表单记录了数据被哪个事务持有锁，当检查到Prepare请求的事务可以提交时回复Yes否则回复No，事务协调者得到所有参与者的Yes后发送Commit请求，并等待参与者Ack。如果在Prepare请求阶段有参与者回复了No，则协调者发送Abort，取消事务。

## 故障恢复

结合故障恢复，来继续讨论上述两阶段提交的设计。

1.如果参与者在接收到Prepare之前或者返回Yes之前就已经故障？那么协调者无法得到所有的Yes，因此事务也不会提交，参与者故障恢复后无需额外的操作。协调者需要做一些得不到响应的补偿，后续会讨论。

2.如果参与者在回复了Yes之后故障？那么协调者可能已经向所有参与者发送了Commit请求，并且其他参与者已经提交了。所以参与者在回复Yes之前必须持久化记住事务所需要做的修改，这样如果故障恢复后收到了Commit提交，参与者还能继续提交。

3.如果参与者在Commit提交之后故障？那么参与者已经完成所有操作，但是协调者没有收到Ack，如果参与者在此收到Commit请求，查询已经没有相关事务记录，则直接Ack即可。

4.如果协调者在Commit发送之前故障？由于没有发送Commit消息，他可以恢复之后直接发送Abort消息，给所有参与者取消事务。

5.如果协调者在发送一个或多个Commit之后故障？那么事务已经提交，协调者必须在发送Commit前就持久化记录事务状态，这样恢复之后，才能继续事物处理。此时协调者可能会向参与者重发Commit请求，所以参与者要做好接收重复Commit的准备（故障3）

6.参与者一旦对Prepare消息回复了Yes之后，那么就要等待Commit或者Abort消息，不能够单方面Abort事务，因为其他参与者可能已经提交。因此它可以等候超时之后向协调者查询事务状态。

7.如果协调者Prepare请求没有得到响应？超时之后可以重发，但是如果某一参与者一直故障，会导致其他参与者一直持有锁，并阻塞了其他事物执行。另一种办法是，他可以Abort取消事务，并向参与者发送Abort消息。如果某个事物参与者故障恢复了或者是Prepare等候超时，并向协调者发送已经被协调者Abort的事务查询请求，协调者会告诉它Abort。

8.如果已经发送了Commit，收不到响应？那么要重发。

9.协调者必然在它的Log中记住了事务的信息，那么它在什么时候可以删除Log中有关事务的信息？答案是，如果事务协调者成功的得到了所有参与者的ACK。

10.一个参与者收到了Commit或者Abort消息，完成了它们在事务中的相应工作，持久化存储事务结果并释放锁，那么在它发送完ACK之后，参与者也可以完全忘记相关的事务。