# 6.824_P13_Spanner

前12节课的视频，建议参考翻译https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/

这篇文章只是记录一些要点和自己的思考，有助于理解第13节课，但和之前的翻译相比，区别较大

Google的分布式数据库，鼎鼎大名的NewSQL，海量数据，易扩展，易维护，支持分布式事物，支持强一致性（external consistency)

## R/W事务

Spanner实现了两阶段锁和两阶段提交。

两阶段锁保证了事务的串行化和一致性，两个事务处理同一个数据时，需要等待前一个事务完成释放锁，后一个事务才能开始。

两阶段提交实现了分布式事务，为了避免单节点故障引起的Block，Spanner每个节点都是一个Paxos Group，只要Group中大多数响应，即可继续进行事务。另外就是，事务的协调者角色分配给某个事务的参与者，能够节省协调开销。

两阶段锁和两阶段提交使用了huge message，导致延时较大。

## R/O事务

对于只读事务，为了提高速度，Spanner实现了就近读取。如果不加任何限制的就近读取，那么一方面可能会违反一致性，比如读取X和读取Y之间由其他关于Y的读写事务发生，另一方面可能会读到旧数据，比如读取的是Paxos Group中的少部分节点（该节点还未同步最新数据）

Spanner解决的方案是多数据版本、时间戳和安全延时。

Spanner对每个数据都保存了多个历史版本，数据版本以事务时间戳标注。对于读写事务，事务的时间戳是事务结束的时间，对于只读事务，事务的时间戳是事务开始的时间。当执行只读事务时，Spanner会查询小于该事务时间戳的最新的数据版本，从而保证读取该只读事务之前的最新数据。

但是即便是取该只读事务时间戳之前的最新数据版本，仍然可能该节点由于执行较慢，处于Paxos Group中的少部分节点，部分数据尚未更新，此时Spanner会延迟事务，等待该节点执行了一个不小于该只读事务的事务，表明该时间戳之前的事务均已同步。

采用时间戳的方法很好，但是不同节点之间是有时间偏斜的，怎么办呢？

## 时钟偏斜

不同节点的时间不同，Google使用GPS、原子钟等各种各样的技术，实现了当获取时间时返回一个区间，即真实时间（TrueTime）不会早于区间最小值，也不会晚于区间最大值。tt.Now() —> [earlist, latest]

基于此设计了两条约束：

1. 事务时间戳选择 tt.Now().Latest
2. 对于RW事务，准备提交时获取时间戳ts，并且等到ts < tt.Now().earlist才提交

RW获取ts = tt.Now().Latest，并且等到ts < tt.Now().Earlist，确保只有当ts时间成为过去时，才提交数据。（避免出现RW事务在真实时间是10提交了时间戳等于20的数据。后续真实时间是15的RO事务，晚于在真实时间10提交的RW事务，获取的时间区间是[6,18]，无法读取到最新数据）同时RO事务获取ts = tt.Now().Latest，由于安全延时的存在，当其查询到大于ts的事务时，数据一定是新的。在RO事务之后的RW事务，时间戳比RO大，不会读取到该RW事务的数据。

反过来思考：

RW事务如果选择时间区间最小值作为时间戳的话， 那么在真实时间10提交的RW事务，数据时间戳可能是5。此时真实时间是8的RO事务，其时间戳可能也是8（无论是选取区间最大值还是最小值），读取了在其之后提交的数据，违反一致性。

RO事务如果选择区间最小值作为时间戳的话，那么在真实时间20发生的RO事务，时间戳可能是10，无法读取到10-20区间提交的数据，发生数据过期。

