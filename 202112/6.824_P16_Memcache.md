# 6.824_P16_Memcache

前12节课的视频，建议参考翻译https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/

这篇文章只是记录一些要点和自己的思考，有助于理解第16节课，但和之前的翻译相比，区别较大

Memcache是facebook开发的缓存数据库。

## 架构演进

当用户不太多时，通常可以把Web前端服务器和数据库系统部署在一台服务器上。

随着用户增多，服务器负载难以承受，此时可以将前端Web服务器和数据库服务器分开，并且可以按需增加前端Web服务器的数量。

随着用户继续增多，数据库服务器成为系统瓶颈，这时可以采用分库分表的策略，将数据分片，使用多台数据库服务器。

当用户继续增加，可以在Web服务器和数据库之间增加一层缓存，也就是Memcache。

缓存的增加，带来了性能的提升，也带来了其他的问题，比如：如何保持缓存数据与数据库数据同步？如何避免缓存击穿和雪崩等等。

## 基本操作

读操作：前端服务器向Memcache请求数据，如果返回为空，则向数据库请求数据，并且将请求得到的数据，发送给Memcache做缓存。

写操作：前端服务器向数据库发送写数据，数据库完成写操作后，前端向Memcache发送删除旧数据操作。（先写后删，避免击穿）

为什么数据库完成写操作后，只是向Memcached发送删除操作，而不是更新操作，假设有这样一种情况，前端先后将数据库中的数据设为1和2，此时数据库中的数据是2，但是发送给Memcache的两条更新信息，2比1先到达Memcache，则Memcache的数据先后被更新为2和1，最终Memcache数据为1，出现了不一致情况。

## 性能

提高性能，一种办法是分区，另一种办法是多副本。前者对应数据分片后者对应数据缓存。对于数据分片来说，没有重复数据，存储效率很高，但是对于热点数据没有什么提升，前端服务器需要维护向多个分区的TCP连接。对于缓存数据来说，前端数据可以将取回来的数据缓存，热点数据可能有多个缓存，解决了热点问题，在缓存数据命中的情况下，前端服务器只需要维护到Memcache的连接，当然副本的数据存储的效率不高。

另外Facebook提到在美国的东西海岸各设了一个数据中心，存储相同的数据，这样做的一个好处是可以就近访问，提高性能（用户请求可能包含数十条数据库查询，如果都需要经过东西海岸之间的网络传输，延时较大，读请求要远高于写请求，写请求的好都要先写到Primary数据中心，再备份到Seconda）。二是可以容灾。

## IN- REGION

在数据中心内部，划分成一个个集群，前端服务器只和集群内部的Memcache通信，同时集群内的Memcache对于一个数据之多保存一份，增大了Memcache可以缓存的数据量。但同时集群不宜过大，因为每一个前端服务器可能要和每一个Memcache进行通信，过多的连接也是一种开销。

## 惊群

比如说某个前端服务器更新了数据库，然后删除了Memcache数据，造成其他大量前端服务器都去数据库请求数据，使得数据库服务器负载过高。

解决方法是第一个请求Memcache的前端服务器，当查询数据缺失时，在Memcache设置一个租约，后续的请求在租约有效期内要等待数据。最先请求数据的前端服务器，获取数据后更新到Memcache。也

## 击穿效应

当一个Memcache宕机后，各种需要该服务器响应的查询得不到响应。如果不加处理，那么前端服务器会直接向数据库发送请求，造成数据库击穿。

解决方法是集群中始终有一些GUTTER SERVER，类似于备份服务器，当前端查询没有网络响应时，会向这些备份服务器发送数据请求。备份数据库可以存储任意数据。数据库更新数据时，也要想备份服务器发送删除消息。

## RACE

C1查询Memcache，K没有命中，然后取数据库取了新的数据V1，准备缓存到Memcache，但是此时C2更新了数据K到V2，并且删除了Memcache的缓存，然后C1才执行到缓存K，V1到Memcache这一个操作，之后Memcache将缓存一个过期数据。

解决方法是C1在查询没有命中时，获取了一个Lease，同时Memcache记录下来。C2更新K并删除Memcache缓存时，将Memcache的Lease同时删除。等到C1将从数据库获取的数据缓存到Memcache时需要携带之前获取的Lease，此时发现携带的Lease与Memcache记录不匹配，则Memcache会拒绝这一缓存请求。

