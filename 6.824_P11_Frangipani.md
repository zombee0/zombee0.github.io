# 6.824_P11_Frangipani

前12节课的视频，建议参考翻译https://mit-public-courses-cn-translatio.gitbook.io/mit6-824/

第11节课讨论的内容是Frangipani。

Frangipani是一篇早期的分布式文件系统的论文。但是他有大量关于缓存一致性、分布式事务和分布式故障恢复的讨论。

Frangipani从架构上来说是一个网络文件系统。工作站上的应用系统运行在Frangipani提供的文件系统上，每个工作站上的文件系统其实是共享存储系统Petal的缓存。

面临的问题，一是修改只是先修改到缓存，其他工作站（缓存节点）上的用户如何才能看到修改后的数据；二是如果两个用户同时修改同一个目录，如何避免相互干扰；三是缓存中的修改需要回写至共享存储，回写的过程中发生故障，如何恢复。

## 锁

在Frangipani系统中除了工作站、共享存储外还有第三类服务器，锁服务器。锁服务器记录了文件名和持有该文件的锁的服务器的相关信息。工作站也记录了文件名、锁状态和文件缓存内容。

当读写文件时，工作站需要先向锁服务器请求锁，并通过一下两条规则来保证缓存一致性：

1.工作站不允许持有缓存数据，除非同时也持有与数据相关的锁。

2.工作站释放锁时，先将缓存数据协会共享服务器，并得到确认后，才释放锁。

## 原子性

一些操作可能设计多个步骤，操作需要保持原子性，对其他工作站来说要么全部存在，要么完全不存在。

简单来说，Frangipani是这样实现分布式事务的：在我完全完成操作之前，Frangipani确保其他的工作站看不到我的修改。首先我的工作站需要获取所有我需要读写数据的锁，在完成操作之前，我的工作站不会释放任何一个锁。并且为了遵循缓存一致性规则，将所有修改了的数据写回到Petal之后，我的工作站才会释放所有的锁。

## Log

工作站在一个复杂操作的过程中故障了，并且其中一部分数据已经在共享存储上进行了修改，如果直接释放锁，那么会导致垃圾、错误数据，如果一直持有锁，那么其他工作站将无法获取锁。

Frangipani采用了预写式日志（WAL）的方法，当他向共享存储写数据前，先记录一条日志，保存操作所需的所有数据和状态。

比较有意思的是，Frangipani将日志保存在共享存储中。并且每个工作站分开独立保存。

当持有锁的工作站崩溃了之后，发生的第一件事情是锁服务器向工作站发送一个Revoke消息，但是锁服务器得不到任何响应，之后才会触发故障恢复。如果没有人需要用到崩溃工作站持有的锁，那么基本上没有人会注意到工作站崩溃了。假设一个其他的工作站需要崩溃了的工作站所持有的一个锁，锁服务器会发出Revoke消息，但是锁服务器永远也不会从崩溃了的工作站收到Release消息。Frangipani出于一些原因对锁使用了租约，当租约到期了，锁服务器会认定工作站已经崩溃了，之后它会初始化恢复过程。实际上，锁服务器会通知另一个还活着的工作站说：看，工作站1看起来崩溃了，请读取它的Log，重新执行它最近的操作并确保这些操作完成了，在你完成之后通知我。在收到这里的通知之后，锁服务器才会释放锁。这就是为什么日志存放在Petal是至关重要的，因为一个其他的工作站可能会要读取这个工作站在Petal中的日志。

## 故障恢复

1.Log没有信息，那么执行故障恢复的工作站可以直接释放锁。

2.部分Log信息，执行故障恢复的工作站执行完整的Log条目，对于不完整的Log条目跳过，完成后释放锁。

3.Log完整写入数据过程中故障，那么执行故障恢复的工作站重复执行一遍，在相同位置写入相同数据不影响正确性，然后释放锁。

这里面有个问题，就是如果工作站1在释放锁的过程中故障了，并且锁已经被释放，后续被另一工作站2获取并修改了数据，那么执行故障恢复的工作站3，按照工作站1的日志恢复数据会引发新的错误。解决方法是给数据增加一个数据版本，只有当版本匹配时才进行修改。